#2.0
    1.  package.json 생성
        ⏩   터미널에 npm init 입력하면 자동으로 생성nodeJS 프로젝트
        ⏩   package.json은 nodeJS 프로젝트
        ⏩   JSON = 프로그래머가 파일에 정보를 저장하기 위해 만든 방식 중 하나 (보통 객체를 생각하면 됌)
            ➕  package.json의 내부는 JSON 방식으로 작성되어 있음

    2.  index.js생성 

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#2.1
    1.  express 설치
        ⏩   npm i express
            ➕  node_modules 폴더 생김
                👉🏻  npm으로 설치한 모든 패키지가 저장
            ➕  packge-lock.json 생성

    2.  package.json 수정
        ⏩   "scripts" : { "server" : "node index.js" }
            ➕  터미널에 npm run dev 입력하면 index.js가 실행된다.
        ⏩   "dependencies" : { "express" :  "^4.18.1" }
            ➕  express가 설치되면서 자동으로 추가 된다.

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞

#2.2
    1.  .gitignore 생성
        ⏩   /node_modules

    2.  npm i 
        ⏩   npm이 package.json의 "dependencies"를 보고 필요한 것들을 모두 설치해준다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#2.3
    1.  babel 설치 방법
        ⏩   babel은 최신식 JS문법을 구식 JS문법으로 변환시켜 nodeJS 가 이해 할 수 있도록 해준다.
        ⏩   babeljs 홈페이지 > Setup > node선택 > 2번 복붙 > babel.config.json 생성 > 4번-shell 복붙 > 4번-JSON을 babel.config.json에 복붙

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞

#2.4
    1.  nodemon 설치 방법
        ⏩   nodemon은 서버의 변동사항을 감지해서 자동으로 서버를 재시작 해준다. 
        ⏩   babeljs 홈페이지 > Setup > nodemon > 2번 복붙 > package.json > npm i nodemon --save-dev > package.json > "scripts" : { "dev" : "nodemon --exec babel-node index.js" } 
    
    

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#3.0
    1.  src 폴더 생성
        ⏩   코드와 로직을 가지고 있는 파일들을 넣는다.
    
    2.  package.json 수정
        ⏩   "scripts": { "dev": "nodemon --exec babel-node src/server.js" }
            ➕  index.js ➡ server.js 파일명 변경 및 경로 변경 
    
    3.  server.js 수정
        ⏩   import express from "express"
            ➕  서버 임포트
        ⏩   const app = express();
            ➕  서버 선언
        ⏩   app.listen(PORT, handleListening);
            ➕  서버에 PORT번호를 부여한다
        ⏩   const handleListening = () => {}

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞

#3.1    
    1.  GET은 HTTP method중 하나다.
 
🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#3.2
    1.  server.js 수정
        ⏩   app.get("/",handleHome)
            ➕  get(route,controller)
            ➕  브라우저가 서버에 "/" 경로로 GET요청을 보내면 handleHome 함수가 실행된다.
        ⏩   const handleHome = () => console.log("Somebody is trying to go home.");

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞

#3.3
    1.  서버중단 하는법
        ⏩   ctrl + c

    2.  controller에는 express가 부여한 req,res object가 있다.
        ⏩   console.log(req/res)

    3.  server.js 수정  
        ⏩   return res.send("I still love you.");
            ➕  res.send()는 ()안의 text를 화면에 출력하고 request를 끝낸다.
            ➕  res.end()는 request를 끝낸다.

    4.  페이지를 만드는 순서 
        ⏩   서버에 route를 지정해주고, controller를 부여한뒤 controller를 작성
    
🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#3.4
    1.  http://expressjs.com/en/5x/api.html#express
        ⏩   express document

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#3.5    
    1.  middleware 설명
        ⏩   request이후 response이전의 소프트웨어
        ⏩   middleware에는 express가 next argument를 부여해준다
    
    2.  server.js 수정
        ⏩   const gossipMiddleware = (req, res, next) => {}
            ➕  console.log(`Someone is going to: ${req.url}`);
                👉🏻  req.url 은 어떤 url로 요청되었는지 확인 할 수 있다.
            ➕  next();
                👉🏻  middleware에 next()를 써야 다음 controller로 넘어간다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#3.6
    1.  globalMiddleware(app.use) 설명
        ⏩   app.use(middleware)
            ➕  app.use(middleware)는 globalMiddleware를 만들 수 있게 해준다.
            ➕  app.use(middleware)는 app.get()보다 먼저 와야 한다.
            ➕  app에 들어오는 모든 요청은 app.use(middleware)를 거쳐 진행된다.
            ➕  app.use(middleware)로 특정 url의 요청은 거부할 수도 있다.
    
    2.  server.js 수정
        ⏩   const logger = (req, res, next) => {}
            ➕  console.log(`${req.method} ${req.url}`);
                👉🏻  req.method 는 요청된 method가 GET인지 POST인지 확인 할 수 있다.
        ⏩   const protectedMiddleware = (req, res, next) => {}
            ➕  if문을 써서 특정 url의 요청을 거부함
        ⏩   app.use(protectedMiddleware);
        ⏩   app.get("/", logger, handleHome);

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#3.7
    1.  package.json 설명
        ⏩   package.json은 node.js 관련 정보를 담는 방법
        ⏩   scripts에 "key"와 "value"를 적으면 npm run key로 value를 실행할수있다.
        ⏩   dependencies는 프로젝트가 돌아가기위해 필요한 파일들 (node_modules폴더에 저장된다)
        ⏩   dependencies가 작성된 상태에서 npm i 하면 npm이 알아서 필요한 파일들을 설치해준다
        ⏩   nodemon은 파일이 수정되고 저장될때마다 서버를 재시작해주는 툴이다
    
    2.  Setup 순서
        ⏩  첫번째로 npm init을 이용해 package.json을 생성
        ⏩  두번째로 npm i express
        ⏩  세번째로 .gitignore 파일 생성 > /node_modules 작성 (그 외 커밋에 제외 할 파일/폴더들 작성)
        ⏩  네번째로 src폴더생성 > main JS 파일 생성
        ⏩  다섯번쨰로 바벨 설치
            ➕  babeljs 홈페이지 > Setup > node > 2번 콘솔에 복붙 > babel.config.json 생성 > 4번-shell 콘솔에 복붙 > 4번-JSON을 babel.config.json에 복붙
        ⏩  여섯번째로 nodemon 설치
            ➕  babeljs 홈페이지 > Setup > nodemon > 2번 콘솔에 복붙 > npm i nodemon --save-dev > package.json > "scripts" : { "dev" : "nodemon --exec babel-node index.js" } 

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#3.8
    1.  서버와 routes
        ⏩   서버는 항상 켜져있고, 인터넷에 연결되어있고, request를 listening 하고있는 컴퓨터다
        ⏩   request는 우리가 서버에게 요청하는 것들
        ⏩   route는 기본url + / , /login , /join , /blahblah 같은 것들을 통칭하는말
        ⏩   method는 서버에 요청을 어떤방식으로 할지 나타내는 것
    
    2.  main JS 작성 순서
        ⏩   첫번쨰로 express를 import해오고 app 변수에 express()를 담는다
            ➕  import express from "express"
        ⏩   두번째로 app에 포트번호를 지정해주고 해당포트번호를 listening 하게 한다
            ➕  const app = express()
        ⏩   세번째로 app에 method를 이용하여 route와 controller를 설정해준다
            ➕  app.get("route",controller)
        ⏩   네번쨰로 controller내부를 작성해준다
            ➕  const controller = (req,res) => {} 

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#3.9    
    1.  controller
        ⏩   controller는 express로부터 req,res 오브젝트를 부여받는다
            ➕  const controller = (req,res) => {} 
        ⏩   req는 요청에 대한 정보를 담고있다. 
        ⏩   controller의 마지막엔 return을 꼭 쓰자
            ➕  const controller = (req,res) => {return res.end()} 

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#3.10
    1.  middleware
        ⏩   미들웨어는 request와 response중간에 있는 소프트웨어
        ⏩   미들웨어는 원하는만큼 작성가능
            ➕  app.get(route,middleware, middleware2 , ... middleware100 ,controller)
        ⏩   미들웨어는 express로부터 req,res 오브젝트와 next 함수를 추가로 부여받는다
        ⏩   next함수는 해당 미들웨어가 실행종료되면 다음 controller로 넘어가게 해주는 역할
            ➕  const middleware = (req,res,next) => {next()}
    
    2.  global middleware
        ⏩   app.use(middleware)
        ⏩   app.use(route,middleware)
        ⏩   app.use()는 app.get()보다 위에 있어야 한다.

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#3.11   
    1.  Morgan middleware
        ⏩   npm i morgan
        ⏩   morgan에는 dev,combined,common,short,tiny 등 옵션이 있다

    2.  server.js 수정
        ⏩   morgan 사용
            ➕  import morgan from "morgan"
            ➕  const logger = morgan("dev");
            ➕  app.use(logger)

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#4.0
    1.  router는 작업중인 주제를 기반으로 url을 그룹화 해준다
        ⏩   /   /login   /join   /search   ...  /users/edit   /users/delete   ...   /videos/watch   /videos/edit   ...
            ➕  해당 프로젝트에서는 globalRouter와 userRouter, videoRouter가 필요

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#4.1
    1.  globalRouter는 home에서 바로 갈 수 있는 것들을 지정한다.
        ⏩   login, join, search 같은 것들

    2.  server.js 수정
        ⏩   globalRouter 생성
            ➕  const globalRouter = express.Router();
            ➕  app.use("/",globalRouter)
            ➕  globalRouter.get("/",handleHome)
            ➕  const handleHome = (req,res) => {res.send("HOME")}
        ⏩   userRouter 생성
            ➕  const userRouter = express.Router();
            ➕  app.use("/users",userRouter)
            ➕  userRouter.get("/edit",handleEditUser)
            ➕  const handleEditUser = (req,res) => {res.send("Edit User")}
        ⏩   videoRouter 생성
            ➕  const videoRouter = express.Router();
            ➕  app.use("/videos",videoRouter)
            ➕  videoRouter.get("/watch",handleWatchVideo)
            ➕  const handleWatchVideo = (req,res) => {res.send("Watch Video")}

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#4.2
    1.  코드 정리
        ⏩   src폴더안에 routers폴더 생성
            ➕  globalRouter.js 생성
                👉🏻  import express from "express"
                👉🏻  const globalRouter = express.Router();
                👉🏻  globalRouter.get("/", handleHome);
                👉🏻  handleHome controller 작성
                👉🏻  export default globalRouter;
            ➕  userRouter.js 생성
                👉🏻  import express from "express"
                👉🏻  const userRouter = express.Router();
                👉🏻  userRouter.get("/edit", handleEditUser);
                👉🏻  handleEditUser controller 작성
                👉🏻  export default userRouter;
            ➕  videoRouter.js 생성
                👉🏻  import express from "express"
                👉🏻  const videoRouter = express.Router();
                👉🏻  videoRouter.get("/watch", handleWatchVideo);
                👉🏻  handleWatchVideo controller 작성
                👉🏻  export default videoRouter;
                    ➡  export default globalRouter는 누군가 globalRouter.js를 임포트하면 globalRouter자체를 임포트하는것이다

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#4.3
    1.  export와 export default의 차이
        ⏩   export는 JS파일 내에서 여러 변수에 적용시킬 수 있다.
            ➕  export default는 JS파일 내에서 하나의 변수만 적용시킬 수 있다.
        ⏩   export는 import 되었을 때 변수명을 일치 시켜야 한다.
            ➕  export default는 import 되었을 때 변수명을 일치 시키지 않아도 된다.

    2.  src폴더안에 controllers폴더 생성
        ⏩   userController.js 생성
            👉🏻  export const join = (req, res) => { res.send("JOIN"); }
            👉🏻  export const edit = (req, res) => { res.send("Edit User"); }
            👉🏻  export const remove = (req, res) => { res.send("Remove User"); }
        ⏩   videoController.js 생성
            👉🏻  export const trending = (req, res) => { res.send("HOME"); }
            👉🏻  export const watch = (req, res) => { res.send("Watch Video"); }
            👉🏻  export const edit = (req, res) => { res.send("Edit Video"); }

    3.  globalRouter.js 수정
        ⏩   import { join } from "../controllers/userController";
        ⏩   import { trending } from "../controllers/videoController";
        ⏩   globalRouter.get("/", trending);
        ⏩   globalRouter.get("/join", join);

    4.  userRouter.js 수정
        ⏩   import { edit, remove } from "../controllers/userController";
        ⏩   userRouter.get("/edit", edit);
        ⏩   userRouter.get("/delete", remove);

    5.  videoRouter.js 수정
        ⏩   import { edit, watch } from "../controllers/videoController";
        ⏩   videoRouter.get("/watch", watch);
        ⏩   videoRouter.get("/edit", edit);

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#4.6
    1.  userController.js 수정
        ⏩   export const login = (req, res) => {}
        ⏩   export const logout = (req, res) => {}
        ⏩   export const see = (req, res) => {}
    
    2.  videoController.js 수정
        ⏩   export const see = (req, res) => {}
        ⏩   export const search = (req, res) => {}
        ⏩   export const upload = (req, res) => {}
        ⏩   export const deleteVideo = (req, res) => {}

    3.  globalRouter.js 수정
        ⏩   import { join, login } from "../controllers/userController"
        ⏩   import { search, trending } from "../controllers/videoController";
        ⏩   globalRouter.get("/login", login);
        ⏩   globalRouter.get("/search", search);

    4.  userRouter.js 수정
        ⏩   import { edit, logout, remove, see } from "../controllers/userController";
        ⏩   userRouter.get("/logout", logout);
        ⏩   userRouter.get("/:id", see);
    
    5.  videoRouter.js 수정
        ⏩   import { see } from "../controllers/userController";
        ⏩   import { deleteVideo, edit, upload } from "../controllers/videoController";
        ⏩   videoRouter.get("/upload", upload);
        ⏩   videoRouter.get("/:id", see);
        ⏩   videoRouter.get("/:id/edit", edit);
        ⏩   videoRouter.get("/:id/delete", deleteVideo);

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#4.7
    1.  url 파라미터 사용법
        ⏩   app.get("/:id",controller)
            👉🏻  /:id 는 여기에 적힌 route를 id라는 변수에 담는다
            👉🏻  controller에서 req.params 하면 파라미터를 조회할수있다.
                ➕  { id : value } 이런식으로 나온다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#4.8
    1.  url 파라미터 정규표현식
        ⏩   (\w+) (\d+)

    2.  videoRouter.js 수정
        ⏩   videoRouter.get("/:id(\\d+)", see);
        ⏩   videoRouter.get("/:id(\\d+)/edit", edit);
        ⏩   videoRouter.get("/:id(\\d+)/delete", deleteVideo);

    3.  userRouter.js 수정
        ⏩   userRouter.get("/:id(\\d+)", see);
        
🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#5.1
    1.  Pug 
        ⏩   npm i pug
        ⏩   pug는 tag를 열고 닫지 않고 들여쓰기로 해결한다.
        ⏩   pug템플릿은 views폴더 안에 작성되어야한다.
        ⏩   pug템플릿을 적용하려면 app.set을 이용하여 view와 view engine을 셋팅 해주어야 한다
    
    2.  server.js 수정
        ⏩   app.set("view engine", "pug")
            👉🏻  view engine을 pug로 셋팅
        ⏩   app.set("views", process.cwd() + "/src/views")
            👉🏻  views는 views폴더의 위치를 셋팅해준다.
            👉🏻  process.cwd()는 package-json의 위치
    
    3.  videoController.js 수정
        ⏩   export const trending = (req, res) => {
            👉🏻  res.render("home")
                ➕  express가 알아서 home.pug를 렌더링 해준다

    4.  views폴더 생성
        ⏩   home.pug 생성
            👉🏻  doctype html 
                html(lang="ko")
                head    
                title Youtube
                body 
                    h1 Welcome to Youtube 
                    footer &copy; 2022 Youtube

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#5.2
    1.  pug에서 JS 변수 사용하는법 
        ⏩   #{} 사용 

    2.  partials폴더 생성
        ⏩   partials폴더는 pug에서 반복되는 구문을 작성한다.
        ⏩   footer.pug 생성
            👉🏻  footer &copy; #{new Date().getFullYear()} Youtube
                ➕  #{}를 이용하여 JS변수를 사용

    3.  home.pug 수정
        ⏩   include partials/footer.pug
            👉🏻  include 명령어는 다른 pug 템플릿을 불러올 때 사용한다.
    
    4.  watch.pug 생성
        ⏩  doctype html 
            html(lang="ko")
                head    
                    title Youtube
                body 
                    h1 Watch Video! 
                    include partials/footer.pug
    
    5.  videoController.js 수정
        ⏩   export const see = (req, res) => {
            👉🏻  res.render("watch")

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#5.3
    1. block 명령어
        ⏩   pug에서 block은 빈공간을 만들어준다.
            👉🏻  다른 템플릿에서 block에 의해 생긴 빈공간을 채울 수 있다.
    
    2. extends 명령어
        ⏩   pug에서 extends는 다른 템플릿을 불러와준다. (확장시킬 템플릿)

    2.  base.pug 생성
        ⏩  doctype html 
            html(lang="ko")
                head    
                    block title
                body 
                    block content
                include partials/footer.pug
            👉🏻  block content는 해당위치에 content라는 block을 만든것

    3.  home.pug 수정
        ⏩  extends base.pug
            block title
                title Youtbe | Home
            block content 
                h1 Home!
            👉🏻  extends base.pug는 base.pug를 불러와서 확장시킨다는 뜻
            👉🏻  block title 한줄아래 들여쓰기로 block을 채울 HTML 태그 작성
    
    4.  watch.pug 수정
        ⏩  extends base.pug
            block title 
                title Youtbe | Watch Video
            block content 
                h1 Watch Video!

    5.  edit.pug 생성
        ⏩  extends base.pug
            block title
                title Youtbe | Edit Video
            block content 
                h1 Edit Video!

    6.  videoController.js 수정
        ⏩   export const edit = (req, res) => {
            👉🏻  res.render("edit")

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#5.4
    1.  JS에서 pug로 변수 넘기기
        ⏩   res.render("pug템플릿",{variable:"value"})
    
    2.  base.pug 수정
        ⏩   title #{pageTitle} | Youtube
            👉🏻  pageTitle 변수 설정

    3   videoController.js 수정
        ⏩   export const trending = (req, res) => {
            👉🏻  res.render("home", { pageTitle: "Home" });
                ➕  res.render의 두번째 parameter로 pug에 pageTitle변수를 넘겨준다

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#5.6
    1.  MVP.CSS
        ⏩   css를 임시적으로 부여해줌
            ➕  html파일의 head부분에 추가
    
    2.  base.pug 수정
        ⏩   link(rel="stylesheet" href="https://unpkg.com/mvp.css")
            👉🏻  MVP CSS 추가 
            👉🏻  head태그 내부에 작성
        ⏩   main 
            👉🏻  main태그 안의 태그들은 브라우저화면의 안쪽으로 모여짐

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#5.7
    1.  PUG 템플릿에서 if, else 사용하기
        ⏩   if true/false
    
    2.  PUG 템플릿에서 JS 변수 사용법 2가지 (controller에서 변수 전달)
        ⏩   h1=pageTitle
        ⏩   h1 #{pageTitle}
            👉🏻  변수 뒤에 다른 텍스트랑 같이 쓸수 있다
    
    3.  base.pug 수정
        ⏩  if fakeUser.loggedIn
                small Hello #{fakeUser.username}
            👉🏻  if문 사용 예제
        ⏩  nav 
                ul 
                    if fakeUser.loggedIn
                        li 
                            a(href="/login") Logout
                    else
                        li 
                            a(href="/login") Login
            👉🏻  if else문 사용 예제
    
    4.  videoController.js 수정
        ⏩   const fakeUser = {}

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#5.8
    1.  PUG 템플릿에서 each in else 사용하기
        ⏩   each item in array
                else 
            👉🏻  for each 구문이랑 비슷하다

    2.  home.pug 수정
        ⏩  each video in videos
                li=video
            else 
                li Sorry nothing found.
            👉🏻  each in else 사용 예제

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#5.9
    1.  Mixin은 partial인데 데이터를 받을수 있는 partial

    2.  videoController.js 수정
        ⏩   const videos = [{}]
    
    3.  mixins 폴더 생성
        ⏩   video.pug 생성  
            👉🏻  mixin video(video)
                    div     
                        h4=video.title
                        ul 
                            li #{video.rating}/5 ...
                ➕  mixin vidoe(video)는 해당 템플릿을 mixin템플릿으로 선언

    4.  home.pug 수정
        ⏩   include mixins/video
            👉🏻  mixin템플릿을 include함으로써 임포트 같은 것이다
        ⏩   each video in videos
                +video(video)
            👉🏻  mixin템플릿을 사용할땐 +mixin(variable) 이런식으로 사용한다
    
🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#6.0
    1.  video.pug 수정
        ⏩   h4
                a(href=`/videos/${video.id}`)=video.title
            👉🏻  PUG에서 태그 속성에는 `${}`을 사용할 수 있다.
    
    2.  videoController.js 수정
        ⏩   export const see = (req, res) => {
            👉🏻  const { id } = req.params;
                ➕  const id = req.params.id 랑 똑같다 
    
    3.  백엔드에 데이터보내는법 app.post(route,controller)

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.1
    1.  videoController.js 수정
        ⏩   export const watch = (req, res) => {}
    
    2.  watch.pug 수정
        ⏩   h3 #{video.views} #{video.views < 2 ? "view" : "views"}
            👉🏻  video.views < 2 ? "view" : "views" 는 삼항연산자를 이용하여 video.views가 복수인지 단수인지 구별해낸다
        ⏩    a(href=`${video.id}/edit`) Edit Video &rarr;
            👉🏻  url은 2가지 종류가 있다 
                ➕  absolute url = a(href="/url")
                    ➡  루트 url부터 바뀐다 localhost:4000/videos/watch >> localhost:4000/url
                ➕  relative url = a(href="url")
                    ➡  끝의 url만 바뀐다 localhost:4000/videos/watch >> localhost:4000/videos/upload

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞        

#6.2    
    1.  videoController.js 수정
        ⏩   export const trending = (req, res) => {}
        ⏩   export const watch = (req, res) => {}
        ⏩   export const getEdit = (req, res) => {}
        ⏩   export const postEdit = (req, res) => {};

    2.  videoRouter.js 수정
        ⏩   videoRouter.post("/:id(\\d+)/edit", postEdit);
            👉🏻  post는 해당 route에서 post 가 전송되었을 때 실행된다.
        
    3.  edit.pug 수정
        ⏩   form(method="post") 
            👉🏻  form을 post방식으로 전송한다 (기본값 = get)
            👉🏻  form(action="")은 form이 전송 될 url을 적는다 (전송 될 url이 현재 위치하고 있는 url이랑 같다면 생략가능)
        ⏩   input(name="title",...)
            👉🏻  form을 post로 전송할 땐, form 안의 input에 name을 지정해주자

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.3
    1.  videoRouter.js 수정
        ⏩   videoRouter.route("/:id(\\d+)/edit").get(getEdit).post(postEdit);
            👉🏻  app.get과 app.post의 route가 동일하면 app.route를 이용하여 한줄로 작성할 수 있다.

    2.  server.js 수정
        ⏩   app.use(express.urlencoded({ extended: true }));
            👉🏻  post된 form을 post controller에서 req.body로 받아오려면 위 작업을 해주어야한다

    3.  videoController.js 수정
        ⏩   export const postEdit = (req, res) => {
            👉🏻  const { title } = req.body;
                ➕  req.body는 post로 전송된 form의 정보를 받아온다
            👉🏻  res.redirect(`/videos/${id}`);
                ➕  redirect(url)은 브라우저를 url로 이동시켜준다.
                ➕  res.render(template)는 template를 html로 변환하여 렌더링시켜 반환해준다.

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞    

#6.5
    1.  videoController.js 수정
        ⏩   export const getUpload = (req, res) => {
        ⏩   export const postUpload = (req, res) => {

    2.  videoRouter.js 수정
        ⏩   videoRouter.route("/upload").get(getUpload).post(postUpload);

    3.  base.pug 수정
        ⏩  nav
                ul 
                    li 
                        a(href="/videos/upload") Upload Video

    4.  upload.pug 생성
        ⏩  extends base
                block content   
                    h3 hello from upload
                    form(method="post")
                        input(name="title",placeholder="Title",required)
                        input(type="submit",value="Upload Video")

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.6 
    1.  videoController.js  
        ⏩   export const postUpload = (req, res) => {
            👉🏻  videos.push(newVideo)
                ➕  array.push(data)는 data를 array의 마지막요소로 추가한다.

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.7
    1.  Mongo DB
        ⏩   문서를 기반으로 하는 DB (JSON형식), 다른 DB는 엑셀처럼 열과 행으로 이루어져 있음
        ⏩   mongo DB 설치 
            👉🏻  https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-windows/

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.8
    1.  Mongo DB 설치 확인
        ⏩   powershell > mongod > mongo > `connecting to: mongodb:url.....` 메시지가 콘솔에 있음
    
    2.  Mongoose
        ⏩   node.js와 mongoDB를 이어주는 package
        ⏩   npm i mongoose
    
    3.  db.js 생성
        ⏩   import mongoose from "mongoose";
            👉🏻  mongoose 임포트
        ⏩   mongoose.connect("mongodb://127.0.0.1:27017/youtube_clone");
            👉🏻  해당 url을 우리의 db로 지정한다
        ⏩   const db = mongoose.connection;
            👉🏻  연결된 db의 정보를 db변수에 담는다
        ⏩   const handleOpen = () => console.log("✅ Connected to DB");
        ⏩   const handleError = (error) => console.log("❌ DB Error ", error);
        ⏩   db.on("error", (error) => console.log("DB Error ", error));
            👉🏻  on()은 콜백함수를 계속 연결한 상태를 유지 
        ⏩   db.once("open", handleOpen);
            👉🏻  once()는 콜백함수를 한번만 연결 후 제거

    4.  server.js 수정
        ⏩   import "./db";
            👉🏻  db.js를 통째로 임포트

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.9
    1.  models 폴더 생성
        ⏩   Video.js 생성
            👉🏻  Video model을 정의할 것이다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.10   
    1.  models폴더 생성
        ⏩   Video.js 생성
            👉🏻  import mongoose from "mongoose";
            👉🏻  const videoSchema = new mongoose.Schema({
                ➕  title: String,
                     description: String,
                     createdAt: Date,
                     hashtags: [{ type: String }],
                     meta: {
                       views: Number,
                       rating: Number,
                       },
                ➕  videoSchema에 우리의 데이터 타입들을 정의해놓는다.
            👉🏻  const Video = mongoose.model("Video", videoSchema);
            👉🏻  export default Video;

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.11
    1.  init.js 생성
        ⏩   server.js에서 server의 구성과 관련없는 코드들을 init.js로 빼옴
    
    2.  videoController.js 수정
        ⏩   import Video from "../models/Video";
            👉🏻  video model 임포트

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.12
    1.  videoController.js 수정
        ⏩   export const home = (req, res) => {
            👉🏻  Video.find({}, (err, videos) => {
                  console.log(err);
                  console.log(videos);
                });
                ➕  Video.find() 같이 db에 요청을 하는 구문은 db로부터 응답받는 시간이 걸린다.
                    db로 부터 응답을 받으면 콜백함수가 실행된다.

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.13
    1.  videoController.js 수정
        ⏩   export const home = async (req, res) => {
            👉🏻  try{
                    const videos = await Video.find({});
                    return res.render("home", { pageTitle: "Home", videos });
                } catch {
                    res.render("error");
                }
                ➕  Video.find() 같이 db에 요청을 하는 구문은 db로부터 응답받는 시간이 걸린다.
                    async + await 는 db로부터 응답을 기다려주고, 응답받은후 다음 코드를 계속 이어나간다.
                ➕  await는 함수 내에서만 실행가능하고, 그함수는 async여야 한다.
                ➕  try catch문을 사용하여 에러검출을 한다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.15
    1.  videoController.js 수정
        ⏩   export const postUpload = (req, res) => {
            👉🏻  const { title, description, hashtags } = req.body;
                const video = new Video({
                    createdAt: Date.now(),
                    hashtags: hashtags.split(",").map((word) => `#${word}`),
                  });
                ➕  Date.now()는 현재 시간을 알려준다
                ➕  String.split(",")는 String을 ,로 구분하여 배열로 return해준다
                ➕  Array.map((word)=>`#${word}`)는 Array에 담긴 모든요소에 `#$word}`를 적용해줌
                ➕  Video model로 객체를 생성하면 mongoose에서 id를 부여해준다
    2.  upload.pug 수정
        ⏩  input(name="description",placeholder="Description",required)
            input(name="hashtags",placeholder="Hashtags, seperated by comma.",required)
    
    mongoose model을 이용하여 데이터를 생성하면 mongoose는 id를 부여해줌 

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.16
    1.  videoController.js 수정 
        ⏩   export const postUpload = async (req, res) => {
            👉🏻  const video = new Video({}
                await video.save()
                ➕  await video.save()는 video객체 만든것을 db에 save해준다.
            👉🏻  awiat Video.create({
                    ...
                })
                ➕  await Video.create()를 이용하여 video객체를 만듦과 동시에 db에 save할수 있다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.17
    1.  videoController.js 수정
        ⏩   export const postUpload = async (req, res) => {
            👉🏻  try{

                } catch(error){
                    return res.render("upload", { pageTitle: "Upload Video", errorMessage: error._message });
                }
                ➕  catch문에서 console.log(error)를 하면 error를 조회할수있다.
    
    2.  Video.js 수정
        ⏩   const videoSchema = new mongoose.Schema({
            👉🏻  createdAt: { type: Date, required: true, default: Date.now },
                ➕  required:true는 해당 프로퍼티를 required로 설정해줌
                ➕  default: Date.now는 해당 프로퍼티의 기본값을 설정해줌
                ➕  default가 있으면 required는 없어도됌

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.18
    1.  Video.js 수정
        ⏩   const videoSchema = new mongoose.Schema({
            👉🏻  title: { type: String, required: true, uppercase: true, trim: true, minLength: 1 },
                description: { type: String, required: true, maxLength: 140 },
                ➕  uppercase는 대문자 전환, trim은 양쪽 공백제거 의 기능을 한다. 

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.19
    1.  videoController.js 수정
        ⏩   export const watch = async (req, res) => {
            👉🏻  const video = await Video.findById(id);
                ➕  url parameter id를 이용하여 Video db에서 video를 조회
    
    2.  videoRouter.js 수정
        ⏩   videoRouter.get("/:id([0-9a-f]{24})", watch);
            👉🏻  mongoose에 부여받은 16진수 24자리 id에 대한 정규표현식

#6.20
    1.  videoController.js 수정
        ⏩   export const watch = async (req, res) => {
            👉🏻   if (!video) {
                ➕  controller에서 video db를 불러왔을땐 에러처리부터 먼저 하자
            
    2.  404.pug 생성

    3.  edit.pug 수정
        ⏩   input(name="hashtags",placeholder="Hashtags, seperated by comma.",required,value=video.hashtags.join())
            👉🏻  array.join()은 array의 요소들을 하나의 string으로 묶어준다
                ➕  ["a","b","c","d"].join() => "abcd"

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.21 ~ #6.22
    1.  videoController.js 수정
        ⏩   export const postEdit = async (req, res) => {
            👉🏻  const video = await Video.exists({ _id: id });
                ➕  Model.exists({condition}) 는 db에 condition(조건)이 존재하는지 확인후 boolean값을 리턴해준다.
            👉🏻   await Video.findByIdAndUpdate(id, {
                ➕  Model.findByIdAndUpdate(id,{})는 id를 이용해 db에서 데이터를 받아오고 {}안의 내용을 업데이트한다.
            👉🏻  hashtags: hashtags.split(",").map((word) => (word.startsWith("#") ? word : `#${word}`))
                ➕  String.startsWith("#")는 String이 #로 시작하는지 확인 후 boolean값을 리턴해준다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.23
    1.  Video.js 수정
        ⏩   videoSchema.pre("save", async function () {
            👉🏻  this.hashtags = this.hashtags[0].split(",").map((word) => (word.startsWith("#") ? word : `#${word}`));
                ➕  schema.pre('save',async function(){})은 schema가 저장되기전에 실행되는 mongoose middleware이다.
                ➕  schema.pre('save',async function(){})는 function내부에 this를 갖고 , this는 저장될 문서를 의미한다. (console.log(this))

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞             

#6.24
    1.  Video.js 수정
        ⏩   videoSchema.static("formatHashtags", function (hashtags) {
            👉🏻  schema.static("functionName",function(parameter)){}는 Model.functionName() 함수를 만들어준다
        
    2.  videoController.js 수정
        ⏩   export const postEdit = async (req, res) => {
            👉🏻  hashtags: Video.formatHashtags(hashtags)
                ➕  schema에 static함수를 적용

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#6.25
    1.  videoController.js 수정
        ⏩   export const deleteVideo = async (req, res) => {
            👉🏻  await Video.findByIdAndDelete(id)
                ➕  Model.findByIdAndDelete는 id를 이용하여 db에서 해당id를 가진 데이터를 지워준다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#6.26~#6.27
    1.  videoController.js 수정
        ⏩   export const search = async (req, res) => {
            👉🏻  const { keyword } = req.query;
                if (keyword) {
                  const videos = await Video.find({
                    title: {
                      $regex: new RegExp(keyword, "i"),
                    },
                  });
                  return res.render("search", { pageTitle: "Search", videos });
                }
                return res.render("search", { pageTitle: "Search" });
                ➕  req.query는 get으로 전달된 form을 받아온다
                ➕  $regex: new RegExp(keyword,"i")는 mongoDB의 regex (정규표현식)이다

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#7.0~7.3
    1.  join.pug 생성

    2.  User.js 생성
        ⏩   import bcrypt from "bcrypt";
            👉🏻  bcrypt는 비밀번호 해싱해주는 패키지,  npm i bcrypt
        ⏩   const userSchema = new mongoose.Schema({
            👉🏻  email: { type: String, requred: true, unique: true },
                ➕  unique는 고유한값으로 설정해준다.
        ⏩  userSchema.pre("save", async function () {
            👉🏻  this.password = await bcrypt.hash(this.password, 5);
                ➕  await bcrypt.hash(password,해싱횟수)
    
    3.  userController.js 수정
        ⏩   export const postJoin = async (req, res) => {
            👉🏻  const exists = await User.exists({ $or: [{ username }, { email }] });
                ➕  한번에 여러 condition을 조회하고싶을때 $or: [ {condition1}, {condition2} ] => return true / false

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#7.4
    1.  userController.js , videoController.js 수정
        ⏩    return res.status(400).render(
            👉🏻  res.status(400) 은 상태코드를 400으로 보낸다.

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#7.5~#7.6
    1.  userController.js 수정
        ⏩   import bcrypt from "bcrypt";
        ⏩   const user = await User.findOne({ username });
            👉🏻  Model.findOne({condition})은 condition에 일치하는 data를 가져다준다.
        ⏩   export const postLogin = async (req, res) => {
            👉🏻  const ok = await bcrypt.compare(password, user.password);
                ➕ await bcrypt.compare(password, db Password) 는 password가 해싱되면 db에 password랑 일치하는지 확인시켜준다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#7.7~#7.8
    1.  server.js 수정
        ⏩   import session from "express-session";
            👉🏻  express-session은 express전용 session 패키지이다. npm i express-session
        ⏩   app.use(
            👉🏻  session({
                    secret: "Hello!",
                    resave: true,
                    saveUninitialized: true,
                })
                ➕  express-session의 기본 셋팅 (추후설명)

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#7.9~#7.10
    1.  userController.js 수정
        ⏩    export const postLogin = async (req, res) => {
            👉🏻  req.session.loggedIn = true;
                req.session.user = user;
                ➕  session에 원하는 object를 추가할수있다.
        
    2.  middlewares.js 생성
        ⏩   export const localsMiddleware = (req, res, next) => {
            👉🏻   res.locals.siteName = "Wetube";
                  res.locals.loggedIn = Boolean(req.session.loggedIn);
                  res.locals.loggedInUser = req.session.user;
                  next();
                };
                ➕  res.locals 는 pug템플릿이 참조할수있는 변수를 설정하는 공간이다.
    
    3.  server.js 수정
        ⏩   import { localsMiddleware } from "./middlewares";
        ⏩   app.use(localsMiddleware);
            👉🏻  app.use(localsMiddleware)는 라우터바로위에 오는것이 좋다.
    
    4.  base.pug 수정
        ⏩   a(href="/my-profile") #{loggedInUser.name}'s Profile
            👉🏻  localsMiddleware에 작성한 loggedInUser변수를 pug 템플릿에서 활용

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#7.12
    1.  session Id는 브라우저 쿠키에 저장되고, session Data는 서버(express)의 memory store에 저장되어 서버가 재시작 되면 session이 날라간다
        session을 유지하기 위하여 Mongo DB에 session을 저장해야 한다.
        ⏩   server.js 수정
            👉🏻  npm i connect-mongo
            👉🏻  import MongoStore from "connect-mongo"
            👉🏻  session middleware내부에 store: MongoStore.create({ mongoUrl: "mongoUrl복붙" }),
                ➕  mongoUrl은 db.js에서 확인 가능
    
🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#7.13
    1.  session middleware에서 resave는 모든 request마다 갖고있던 session이 수정되지 않아도 그 session을 재저장 하는 옵션
        saveUninitialized는 request가 들어오면 해당 request에서 새로 생성된 session이 수정되지 않아도 그 session을 저장 하는 옵션
        ⏩   server.js 수정
            👉🏻  resave: false,
                saveUninitialized: false,
                ➕  수정된것도 없는데 매번 session이 재저장되면 비효율적

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#7.14 ~ #7.15  
    1.  브라우저 - F12 - Application - Cookies에는 property들이 많다.
        secret = session을 우리 백엔드만 알아볼수 있도록 암호화 해준다.
        Domain = cookie를 만든 백엔드가 누구인지 알려줌 / cookie는 Domain으로 전송됨
        expire / Max-Age = 세션의 만료기한에 대한 정보 => cookie:{maxAge:1000} = 세션 만료기한 1초 (단위 ms)
        ⏩   server.js 수정
            👉🏻  cookie: { maxAge: 3600000 }, 
                ➕  쿠키의 만료기한을 3600초로 설정

    2.  환경변수(environment variable)는 보안상 코드에 들어가면 안되는 값들을 변수로 설정해준다.(mongoDB의 URL, Session의 secret 등)
        환경변수는 'dotenv 패키지'를 필요로 하며 '.env'파일에 작성을 하고 'process.env.변수명' 으로 사용 가능하다 (.env 파일은 .gitigonre에 등록되어야 한다)
        'dotenv 패키지'는 모든 import문중에서 제일 먼저 import되는것이 좋다
        ⏩   .env 생성
            👉🏻  COOKIE_SECRET=dmgajkn12on1kgh89queh192r81y8nciu
                DB_URL=mongodb://127.0.0.1:27017/youtube_clone
                ➕  mongoDB의 URL과 Session의 secret을 환경변수로 지정해준다.
        ⏩   .gitignore 수정
            👉🏻  .env 추가
        ⏩   npm i dotenv
            👉🏻  dotenv 패키지 설치
        ⏩   init.js 수정
            👉🏻  import "dotenv/config";
                ➕  모든 import문 중에서 제일 먼저 오도록 해준다
        ⏩   db.js 수정
            👉🏻  mongoose.connect(process.env.DB_URL, {
                ➕  env파일안에 DB_URL 변수를 사용
        ⏩   server.js 수정
            👉🏻  secret: process.env.COOKIE_SECRET,
                ➕  env파일안에 COOKIE_SECRET 변수를 사용

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#7.16~#7.21
    
    1.  소셜로그인 구현하는법 (깃헙로그인)
        ⏩   흐름 : 깃헙로그인버튼을 누르면 사용자를 깃헙으로 보낸다  > 
                    사용자가 깃헙 이메일비번등을 입력하고 자기 정보를 깃헙에서 우리서버에 공유하는것을 승인한다 > 
                    깃헙은 사용자를 우리 웹사이트로 보낸다 > 
                    깃헙은 사용자를 token과함께 redirect시킨다 > 
                    우리는 그 token으로 사용자의 정보를 받아온다(token은 빠르게 만료된다)

        ⏩   순서
            👉🏻  0. 구글에 github oauth 입력후 나오는 GitHub Docs에 들어간다 (https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-app)
            👉🏻  1. 깃헙 Application 생성
                ➕  My Github  
                    > 내 아이콘 클릭 후 Settings 
                    > 왼쪽 Developer settings 
                    > OAuth Apps 
                    > New OAuth App 
                    > name, URL, description 작성
                    > Authorization callback URL 에 'http://localhost:4000/users/github/finish' 작성
                    > Register application 버튼 
                    > Client ID, Client secrets가 있는 페이지가 나온다
            👉🏻  2. login.html에 user를 GitHub로 보내줄 a태그를 작성
            👉🏻  3. a태그의 href를 /users/github/start로 작성하고 router와 controller를 만든다
                ➕  GitHub에서 Client Id를 부여받고 환경변수(GH_CLIENT)로 담는다 (범용성의 이유) 
                    > controller 내부에 config객체를 생성 후 allow_id, client_id, scope 등의 parameter를 property로 담는다 
                        ( parameter종류는 GitHub Docs의 1번 URL 아래에 있고, 스네이크표기법을 사용해야한다 )
                    > baseUrl변수를 만들어 GitHub Docs의 1번에 있는 url을 담아주고 
                    > params변수를 만들어 config 객체를 인코딩 시킨다. 
                        ( const params = new URLSearchParams(config).toString() )
                    > finalUrl변수를 만들어 baseUrl과 params를 합치고 finalUrl을 redirect 시켜준다 
                        ( params앞에는 ? 가 있어야한다 )
            👉🏻  4. 유저가 a 태그를 누르면 유저는 GitHub로 보내지게 되고
                    GitHub에서 정보 공유에 대한 승인을 누르면 GitHub는 1번에서 입력한 Authorization callback URL에 GET요청을 보내고 
                    url query로 code를 보여준다 (주소창에서 확인가능)
            👉🏻  5. Autorization callback URL에서 설정한 url의 router와 controller를 만들어준다
                ➕  GitHub에서 Client secrets를 부여받고 환경변수(GH_SECRET)로 담는다 (보안상의 이유)
                    > controller 내부에 config 객체를 생성 후 client_id, client_secret, code 등의 parameter를 property로 담는다 
                        ( code값은 req.query.code ) ( parameter종류는 GitHub Docs의 2번 URL 아래에 있고, 스네이크표기법을 사용해야한다 )
                    > baseUrl변수를 만들어 GitHub Docs의 2번에 있는 url을 담아주고 
                    > params변수를 만들어 config 객체를 인코딩 시킨다.
                        ( const params = new URLSearchParams(config).toString() )
                    > finalUrl변수를 만들어 baseUrl과 params를 합친다.
                        ( params앞에는 ? 가 있어야한다 )
                    > data변수를 만들고 fetch함수를 이용해 finalUrl의 서버로 post로 요청한다. fetch(url)은 다른서버를 통해 데이터를 가져오는 함수다
                        ( const data = await fetch(finalUrl, { method:"post" }) )
                    > fetch함수로 받아온 데이터를 json형태로 변환해준다.
                        ( const json = await data.json() )
                    > json을 리턴받기위해 추가작업을 해준다
                        ➡  5-1. await fetch (finalUrl, { method: "post", }에서 method property 다음에 headers property를 추가 ( headers:{} )
                        ➡  5-2. GitHub Docs의 2번째 URL Response부분에서 두번째 box에 적혀있는 Accept: application/json 을 복사하여 headers:{}내부에 붙여넣기
                        ➡  5-3. Accept: application/json 에서 application/json부분을 "application/json"로 바꿔준다.
                    > fetch()를 동작시키기 위해 npm install node-fetch@2.6.1 를 하고 node-fetch를 import fetch from "node-fetch"해준다
                    　  ( 브라우저와 NodeJS는 똑같이 JS를 사용하지만 NodeJS에서는 정의되지 않은 JS함수들이 있다. 예를들어 alert, fetch )
                    > console.log(json)을 하면 access_token과 token_type과 scope를 받은걸 확인 할 수 있다.
            👉🏻  6. json 안의 access_token을 갖고 API에 접근하여 유저의 정보를 얻는다
                ➕  json안에 access_token이 담겨있다면 json으로부터 access_token을 꺼내어 access_token 변수에 담고,
                    GitHub Docs의 3번째 GET 요청 URL에 fetch를 써주고 headers에 json으로 부터 받은 access_token을 함께 보낸다.
                    만일 json안에 access_token이 없다면 login 페이지로 redirect 시켜준다
                    >   if("access_token" in json){　　
                      　    const {access_token} =json
                      　    const userData= awiat fetch("https://api.github.com/user", {　
                      　        heaers: {　
                      　　　        Authorization: `token ${access_token}`,　　
                                },
                            });
                      　} else {
                      　    return res. redirect("/login");　　
                      　}
            👉🏻  7. const fialUrl 아래줄부터 코드를 전부 포맷팅 해주자
                ➕  const tokenRequest = await (await fetch(finalUrl, { method:"POST", headers:{ Accept:"application/json",},})).json();
                    ( const json = await data.json(); 은 지워주자)
                    if ("access_token" in tokenRequest) {
                        const { access_token } = tokenRequest;　
                        const userData= await (await fetch("https://api.github.com/user",{ headers:{ Authorization: `token ${access_token}`,},})).json();
                    }
                    else { return res.redirect("/login");}
            👉🏻  8. 이렇게 하면 user의 정보를 불러올수 있지만, email이 private일 경우 email:null 이라고 나온다, 이럴때 해결방안
                ➕  const userData다음에 const emailData를 선언
                    >   const emailData = await ( await fetch("https://api.github.com/user/emails", { headers: { Authorization: `token ${access_token}`,},})).json();
                        console.log(emailData);
            👉🏻  9. emailData변수 다음에 email변수를 만들어서 emailData에서 verified이면서 primary인 email데이터를 찾아서 변수에 email변수에 담는다
                ➕  const emailObj = emailData.find((email)=>email.primary===true && email.verified===true);
                　 　>  if(!emailObj){return res.redirect("/login")
            👉🏻  10. emailObj안의 email이 이미 UserDB에 존재하는지 확인하고 존재한다면 해당유저를 login시킨다
                ➕  const existingUser = await User.findOne({ email: emailObj.email });
                    if (existingUser) {
                        req.session.loggedIn = true;
                        req.session.user = existingUser;
　                      return res.redirect("/");
                    } else{

            👉🏻  11. emailObj안의 email이 UserDB에 존재하지 않는다면 해당 email로 유저를 만든다
                ➕  else {
                        //create an account
                        const user = await User.create({
                            name: userData.name,
                            username: userData.login,
                            email: emailObj.email,
                            password: "",
                            location: userData.location,
                            socialLogin: true,
                            avatarUrl: userData.avatar_url,
                        });
                        req.session.loggedIn = true;
                        req.session.user = user;
                        return res.redirect("/");
                    }

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#7.22
    1.  userController 수정
        ⏩   export const logout = (req, res) => {
            👉🏻  req.session.destroy();
                ➕  세션을 파괴한다.

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#8.0
    1.  middlewares.js 수정
        ⏩   res.locals.loggedInUser = req.session.user || {};
            👉🏻  login 되지않은 유저가 /users/edit를 요청하면 에러페이지에 pug템플릿이 노출된다. (loggedIn.username을 찾을수 없다는식으로)
                그것을 막기위해 || {} 를 추가하여 loggedInUser가 undefined되는 현상을 막는다
                ➕  허나, 저렇게되면 로그인하지 않은 유저가 /users/edit에 접근이 가능해지기 떄문에 이 에러를 따로 막아야한다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#8.1
    1.  middlewares.js 수정
        ⏩   export const protectorMiddleware = (req, res, next) => {
                if (req.session.loggedIn) {
                  next();
                } else {
                  return res.redirect("/login");
                }
            👉🏻  로그인 하지않은 유저가 /users/edit 같은 페이지에 들어가는걸 막아주는 미들웨어
        ⏩   export const publicOnlyMiddleware = (req, res, next) => {
                if (!req.session.loggedIn) {
                    return next();
                } else {
                    return res.redirect("/");
                }
            👉🏻  로그인 한 유저가 /login 같은 페이지에 들어가는걸 막아주는 미들웨어

    2.  userRouter.js 수정
        ⏩   userRouter.route("/edit").all(protectorMiddleware).get(getEdit).post(postEdit);
            👉🏻  route.all(middleware)은 get과 post 둘다에게 적용되는 미들웨어를 사용할 때 쓴다.
            
🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#8.2 ~ 8.3
    1. userController.js 수정
        ⏩   export const postEdit = async (req, res) => {
            👉🏻  session: { user: { _id, email: sessionEmail, username: sessionUsername },},
                ➕  한 object에서 여러 property를 불러올때 사용하는 방법 ES6
        ⏩   const updatedUser = await User.findByIdAndUpdate(_id,{name,username},{new:true})
            👉🏻  Model.findByIdAndUpdate()는 첫번째 인자로 id를 받고 두번째 인자로 update할 내용들을 받는다.
            👉🏻  Model.findByIdAndUpdate()는 기본적으로 업데이트전 데이터를 반환한다. 업데이트 후 데이터를 반환하려면 세번째 인자로 {new:true}를 해준다

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#8.4~#8.5 
    1.  userController.js 수정
        ⏩   export const getChangePassword = (req, res) => {
            👉🏻  if (req.session.user.socialLogin) {return res.redirect("/");}
                ➕  소셜로그인한사람은 change Password 페이지에 접근할수 없다.
        ⏩   export const postChangePassword = async (req, res) => {
            👉🏻  user.password = newPassword;
                await user.save();
                ➕  user.save()는 await를 꼭 해주자! ( 몽고디비에 접근 )

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#8.6~#8.8
    1.  Multer package
        ⏩   multer는 form으로 부터 받은 파일을 어디에 저장할지 지정해주는 미들웨어
        ⏩   npm i multer
    
    2.  파일 업로드하는법
        ⏩   pug에서 file을 받는 input을 만들어준다
    　      👉🏻  form에 enctype="multipart/form-data" 속성을 추가
    　      👉🏻  form 내부에 label( for="avatar") Avatar 추가
    　      👉🏻  label 아래줄에 input( type="file", id="avatar", name="avatar", accept="image/*" ) 추가
                ➕  { label은 input id를 따르고 accept="image/*"는 image파일만 허용함 } 
    
        ⏩   Multer를 설치하고 middleware.js에 middle ware를 작성한다
    　      👉🏻  npm i multer
    　　        ➕  { Multer는 form으로 부터 오는 파일을 어디에 저장할지 지정해주는 미들웨어 }
    　      👉🏻  import multer from "multer"
    　      👉🏻  export const uploadFiles = multer( { dest:"uploads/" } )
    　　        ➕  { dest는 파일을 저장할 위치(폴더명)이고 uploads폴더가 자동으로 생성됨 }
    
        ⏩   uploads폴더를 .gitignore에 추가한다
            👉🏻  /uploads
    
        ⏩   router에 multer middelware를 적용시킨다
    　      👉🏻  userRouter.route("/edit").~~~.post( uploadFiles.single("avatar"), postEdit )
    　　        ➕  { single은 파일을 한개만 선택한다는 뜻이고 single()안에는 type=file인 input의 name을 쓴다 )
    
        ⏩   controller에서 form으로부터 전송된 file을 받아서 데이터에 적용시킨다
    　      👉🏻  postEdit controller 내부에 req.file , req.session.user.avatarUrl
    　      👉🏻  postEdit controller 내부에 const updateUser 내부에  avatarUrl : file ? file.path : avatarUrl 추가
    　　        ➕  { modelScheema에 avartarUrl:String이 있어야함 }
    
        ⏩   pug에서 req.file을 통해 가져온 이미지를 띄워보자
    　      👉🏻  img( src="/"+ loggedInUser.avatarUrl )
    　　　　    ➕  { "/"를 붙히지 않으면 relative Url로 적용된다 }
    
        ⏩   server.js에서 브라우저를 upload폴더에 접근할수 있도록 설정해주어야 한다. ( static files serving )
    　      👉🏻  app.use( "/uploads", express.static("uploads"))

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#8.9    
    1.  watch.pug 수정
        ⏩   video(src="/"+video.videoUrl, controls)
            👉🏻  video 태그의 속성으로 controls는 controler를 보여준다
    
    2.  middlewares.js 수정
        ⏩   export const avatarUpload = multer({
            👉🏻  limits: {fileSize: 3000000,} 
                ➕  업로드 파일의 크기를 설정할때 사용한다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#8.10
    1.  userController.js 수정
        ⏩   export const see = async (req, res) => {}

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#8.11   
    1.  Video.js 수정
        ⏩   owner: { type: mongoose.Schema.Types.ObjectId, required: true, ref: "USER" },
            👉🏻  Video Scheema에 owner를 추가
                ➕  mongoose.Schema.Types.ObjectId는 mongoose에서 제공하는 ObjectId 타입이고 mongoose 코드에서만 쓸수있다.
                ➕  ref는 이 owner라는 object 타입의 objectId가 어떤 Model로부터 오는지 설정해준다.
    
    2.  watch.pug 수정
        ⏩   if String(video.owner)===loggedInUser._id
            👉🏻  video.owner는 object 타입이므로 String으로 변환해준다

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#8.12
    1.  videoController.js 수정
        ⏩   const video = await Video.findById(id).populate("owner");
            👉🏻  populate("owner")는 owner값으로 videoSchema에 owner가 참조하고있는 User.js를 참조하여 데이터를 불러온다.
                ➕  owner는 populate가 발생시 ref에 설정되었던 User.js를 참조하고, owner의 값으로 User.js에서 값과 일치하는 id를 가진 User 데이터를 리턴한다.
    1.  userController.js 수정
        ⏩    const videos = await Video.find({ owner: user._id });
            👉🏻  Model.find({condition})은 array를 return한다 ( condition에 맞는 데이터가 여러개 일 수 있기 때문 )

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#8.14
    1.  User.js 수정
        ⏩     userSchema.pre("save", async function () {
                    if (this.isModified("password")) {
                        this.password = await bcrypt.hash(this.password, 5);
                    }
            👉🏻  비밀번호 해싱이 한번만 일어나도록 isModified("password")를 사용하였다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#9.0    
    1.  Webpack은 JS의 최신문법들을 브라우저가 이해할수 있게 해준다 (프론트엔드의 babel같은 역할)
        재미없고 잘안쓰지만 업계표준이고 이해할 필요는 있다.
        (리액트,리액트네이티브,대부분의 프레임워크엔 웹팩이 내장되어 있어서 직접 사용할일은 거의 없다.)
        너무어렵거든 Gulp강의를 보고오자

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#9.1~#9.3
    1.  webpack
        ⏩   우리가 webpack에게 넘겨주는 모든 파일들을 받아서 loader를 통하여 변환해준다.(babel loader, scss 등등)
            👉🏻  솔직히 잘안씀 업계표준이고 재미는없지만 이해해야할 필요는 있다
                ➕  리액트,리액트네이티브,대부분의프레임워크엔 웹팩이 내장되어있다
                    그래서 웹팩을 직접 사용할일은 거의없다

    2.  웹팩설치, 바벨로더 설치
        ⏩   npm i webpack webpack-cli -D
            npm i babel-loader -D
            (-D는 devDependencies에 저장을 의미)

    3. webpack.config.js 생성
        ⏩   이파일은 js의 오래된 문법만 이해할수있어
            👉🏻  const path = require("path");
                module.exports{
                    entry:"./src/client/js/main.js",
                    mode: "development",
                    output:{
                        filename:"main.js",
                        path:path.resolve(__dirname,"assets","js"`),
                    },   
                    modules:{
                　　    rules:[
                        　　{
                                test:\.js$/,
        　　                    use:{
                                    loader:"babel-loader",
                                    options:{
                                        presets:[["@babel/preset-env",{targets:"defaults"}]],
                                    },
                                },
                        　　},
                　　    ],
                    },
                }   
                ➕  entry는 webpack으로 보내버릴 파일들
                ➕  mode는 내가 아직 개발중인지,아니면 이 파일이 완성품인지 알려준다
                ➕  output은 webpack을 통해 변환된 파일의 파일명,저장경로
                ➕  path.resolve는 해당경로에 몇개가되었든 우리파일을 저장해준다
                ➕  __dirname은 현재 파일의 경로를 리턴해주는 js코드
                ➕  rules는 webpack에서 우리가 각각의 파일종류에 따라 어떤 전환을 할건지 결정하는것
                    ✅  option부분만 사용하는 로더에따라 바뀐다.

    4.  scripts 추가
        ⏩   "assets":"webpack --config webpack.config.js"

    5.  server.js 수정
        ⏩   app.use("/assets",express.static("assets"))
            👉🏻  assets폴더에 접근할수있게 assets라우터를 설정해줌
            👉🏻  express.static("폴더명")은 해당 폴더를 누구나 접근할수 있게 해줌

    6.  base.pug에서
        ⏩   script(src="/assets/js/main.js")
            👉🏻  webpack에서 리턴해준 main.js에 접근시켜줌

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#9.4
    SCSS적용법1

    1.  src> client> scss폴더 생성
    
    2.  scss> styles.scss 생성
        ⏩   @import "./_variable";
            body { color : $red }
            👉🏻  scss에서 변수 사용법

    3.  scss> _variable.scss 생성
        ⏩   $red : red;
            👉🏻  scss에서 변수 설정법
    
    4.  
        npm i sass-loader sass webpack --save-dev
        npm i --save-dev css-loader
        npm i --save-dev style-loader

    5.  webpack.config.js 수정
        ⏩   {
                test: /\.scss$/,
                use: ["style-loader","css-loader","sass-loader"],
              }
            👉🏻  여러 로더들을 한번에 합칠땐 use:[], 실행 역순으로
            👉🏻  sass-loader는 scss파일을 가져다가 css파일로 전환시켜줌
            👉🏻  css-loader는 @import와 url()을 풀어서 해석해줌
            👉🏻  style-loader는 css를 DOM에 주입한다

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#9.5
    SCSS적용법2  (webpack 플러그인=MiniCssExtractPlugin 사용)
    MiniCssExtractPlugin은
    scss를 별도의  css파일로 만들어준다

    1.  src> client> scss 폴더생성
    
    2.  scss> styles.scss 생성
        ⏩   @import "./_variable";
            body { color : $red }
            👉🏻  scss에서 변수 사용법

    3.  scss> _variable.scss 생성
        ⏩   $red : red;
            👉🏻  scss에서 변수 설정법

    4.  npm i sass-loader sass webpack --save-dev
        npm i --save-dev css-loader
        npm install --save-dev mini-css-extract-plugin

    5.  webpack.config.js 수정
        ⏩   const MiniCssExtractPlugin = require("mini-css-extract-plugin");
        ⏩   module.export={ }안에 plugins:[new MiniCssExtractPlugin()],
        ⏩   output : { }안에 filename: "js/main.js", path: path.resolve(__dirname, "assets"),
        ⏩   rules : [ ]안에　{ test : /\.scss$/, use : [ MiniCssExtractPlugin.loader, "css-loader", "sass-loader" ],},
            👉🏻  여러 로더들을 한번에 합칠땐 실행 역순으로
            👉🏻  sass-loader는 scss파일을 가져다가 css파일로 전환시켜줌
            👉🏻  css-loader는 @import와 url()을 풀어서 해석해줌

    6.  npm run assets
        ⏩   assets/js에 main.css파일이 생성된다

    7.  base.pug 수정
        ⏩   base.pug에서 head안에 link(link rel="stylesheet" href="/assets/css/styles.css")
            👉🏻  미리 server.js에서 /assets경로를 static으로 지정해주어야한다

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#9.6
    scss, client 등 프론트쪽의 수정이 일어날때 webpack을 자동으로 실행해주는법

    1.  webpack.config.js 수정
        ⏩   module.exports = {}안에
            👉🏻  watch : true,
                ➕  scss,client쪽에서 수정이 일어날때마다 npm run asstets를 자동으로 해준다 (초기한번은 수동실행)
        ⏩   output : {}안에
            👉🏻  clean : true,
                ➕  output내에 path경로에서 build가 시작되기전에 clean을 해준다 (뭔소린지모르겠음)
    
    2.  nodemon.json 생성, package.json 수정
        ⏩   {
                "igonore": [ "webpack.config.js", "src/client/*", "assets/*" ],
                "exec" : "babel-node src/init.js"
            }
        ⏩   package.json 에서 "scripts" : {}안에
            👉🏻  "dev":"nodemon",
                "assets":"webpack"
                ➕  scss나 client등 front쪽의 파일들이 저장될때, backend가 재실행 되는것을 막아준다.

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#11.0
    1.  webpack.config.js 수정
        ⏩   enrty:{ main : "./src~~~main.js", videoPlayer : "./src~~~videoPlayer.js" }
            👉🏻  entry에 여러가지 파일을 등록할수 있다.
        ⏩   output : { filename : "js/[name].js" }
            👉🏻  Webpack이 [name]칸을 알아서 entry의 프로퍼티랑 일치시켜서 파일명을 반환해준다

🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       

#11.1   
    1.  videoPlayer.js 수정 
        ⏩   if(video.paused){
                video.play()
            }
            👉🏻  video.paused는 true,false를 리턴해준다
            👉🏻  video.pause()는 video를 pause시켜준다
            👉🏻  https://developer.mozilla.org/ko/docs/Web/API/HTMLMediaElement

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈

#11.2~#11.3
    ⏩   const handleMute = (e) => {}

🌈        🌈          🌈          🌈          🌈          🌈          🌈          🌈
🌞        🌞          🌞          🌞          🌞          🌞          🌞          🌞       
❤🧡💛💚💙💜🤎🖤❤🧡💛💚💙💜🤎🖤❤🧡💛💚💙💜🤎🖤❤🧡💛💚💙💜🤎🖤❤🧡💛💚💙💜🤎🖤❤🧡💛💚💙💜🤎🖤❤🧡💛💚💙💜🤎🖤
여태까ㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈㅈ지 배운걸 토대로 순서

1.  npm init을 이용해 package.json을 생성

2.  npm i express

3.  .gitignore 파일 생성 > /node_modules 작성 (그 외 커밋에 제외 할 파일/폴더들 작성)

4.   src폴더생성 > main JS 파일 생성

5.  바벨 설치
    ⏩  babeljs 홈페이지 > Setup > node > 2번 콘솔에 복붙 > babel.config.json 생성 > 4번-shell 콘솔에 복붙 > 4번-JSON을 babel.config.json에 복붙

6.  nodemon 설치
    ⏩  babeljs 홈페이지 > Setup > nodemon > 2번 콘솔에 복붙 > npm i nodemon --save-dev > package.json > "scripts" : { "dev" : "nodemon --exec babel-node index.js" } 

7.  express를 import해오고 app 변수에 express()를 담는다
    ⏩  import express from "express"
    ⏩  const app = express();

8.  app에 포트번호를 지정해주고 해당포트번호를 listening 하게 한다
    ⏩   app.listen(PORT,handleListening)
        ➕  const PORT 작성
        ➕  const handleListening(){} 작성

9.  morgan 설치
    ⏩   npm i morgan

10. morgan을 import해오고 logger변수에 morgan("dev")을 담는다
    ⏩   import morgan from "morgan"
    ⏩   const logger = morgan("dev")

11. app.use로 logger 미들웨어를 지정한다
    ⏩   app.use(logger)

12. README.md 파일에 라우터들을 정리해준다
    ⏩   /   /login  /users/:id  /users/:id/edit   /videos/:id   /videos/upload ...

13. src 폴더 > routers폴더 생성 > 각각의 router.js 생성

14. 각각의 router.js 내부에 express import와 router선언
    ⏩   import express = "express";
    ⏩   const ---Router = express();

15. 각각의 router.js 내부에 route와 controller 부여
    ⏩  ---Router.get("route",controller)

16. 각각의 router.js 내부에 router변수를 export default
    ⏩  export default ---Router

17. server.js에서 ---Router들 import
    ⏩   import ---Router from "./routers/---Router";

18. src 폴더 > controllers폴더 생성 > 각각의 controller.js 생성nodeJS

19. 각각의 controller.js 내부에 controller 작성
    ⏩   const home = (req,res) => {}

20. 각각의 controller.js 내부에 controller에 export 추가
    ⏩   export const home = (req,res) => {}

21. 각각의 router.js 내부에 controller를 import
    ⏩   import { controller, controller2 } from "controller.js 경로"

22. pug 템플릿 설치
    ⏩   npm i pug

23. src폴더 > views 폴더 생성 > base.pug 생성

24. main JS에서 view,view engine 셋팅
    ⏩   app.set("view","pug")
    ⏩   app.set("view engine", process.cwd()+"/src/views")

25. views폴더에 필요한 pug들 생성
    ⏩   mixins폴더와 partials폴더 생성

26. router에 app.post를 이용하여 post router도 추가

27. router에 app.get과 app.post가 같은 url을 사용하는게 있다면 app.route로 합쳐주자

28. npm i mongoose

29. db.js 생성

30. models 폴더 생성
    ⏩   Video.js같은 모델파일 생성후 작성

31. init.js를 따로만들어 sever.js에는 sever의 설정과 관련된것만 남기고 나머지는 init.js로 옮겨줌
    ⏩   package.json에서 script를 server.js에서 init.js로 변경해주어야함

32. controller에 Video model을 적용시키고 Video model (db)에 접근할땐 async await 잘 써주자


